---
layout: post
title: 趣谈网络协议
date: 2018-12-17
author: Jerry
header-style: text
catalog: true
tags:
 - 读书笔记
 - 计算机网路
---

## 网络分层的真实含义

1. 只要是在网络上跑的包，都是完整的。可以有下层没上层（例如MAC层发现不是发给本机的包后，直接丢弃），但是不可能有上层没下层的情况出现
2. 网络分层的目的在于解决复杂度问题，上层总是依赖于下层，并不是能够独立存在

### 各层之间调用实现方式

下层是知道上层的存在的，可以通过每一层包头里面查看上层用的是什么协议。每一层的处理函数都会在OS启动的时候，注册到内核一个数据结构里面。当数据包到达某一层的时候，通过判断上层是什么协议，然后去找相应的处理函数去调用

## ifconfig&ip addr 发生了什么

### 需要掌握的基础：
- IP地址划分，A/B/C/D/E共5类。
- 无类型域间选路 CIDR
- 如何计算网络号、子网掩码等
- 知道IP中公网地址与私有地址的范围

### 既然MAC地址全世界唯一，为什么不直接用MAC地址通信，还要引入IP

要实现能够两台主机的通信，还需要定位功能，如果直接用MAC地址通信，那么需要建立的映射关系将特别多，考虑到当前如此多的计算机，建立如此大的映射关系不现实，所以引入IP进行定位功能。只有在同一个网络号里面的主机才能用MAC地址进行通信。

### ip addr 详解

`ifconfig`属于`net-tools`工具包，而`ip addr`来自`iproute2`工具包，`iproute2`工具包的出现旨在替换`net-tools`，因为其增加了更多新特性，以及更加统一的命名方法，更加容易使用。但由于历史遗留原因，`net-tools`工具包仍然被广泛应用于现在的系统中。

```
root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:fec7:7975/64 scope link 
       valid_lft forever preferred_lft forever

```
以上命令列出了系统中当前存在的所有网卡。

`lo` 表示`loopback`，又称环回接口，往往被分配到`127.0.0.1`这个地址上。这个地址用于**本机通信**，经过**内核处理后直接返回**，不会在任何网络中出现。与此对应的，`scope`中host表示这张网卡仅仅可以供本机相互通信。而global表示这张网卡是可以对外的。

`UP`表示网卡处于启动状态

`BROADCAST`表示这个网卡有广播地址，可以发送广播包

`MULTICAST`表示该网卡可以发送多播包

`LOWER_UP`表示L1是启动的，也即使用网线联网。

`MTU 1500`对应于MAC层允许支持的最大报文长度，加上MAC头部尾部最大共1518字节，如果过长就要进行分片。1500为以太网的默认值。此外，TCP层有一个MSS(Maximum Segment Size，最大分段大小)，它等于MTU减去IP头，再减去TCP头的长度。即在不分片的情况下，TCP里面放的最大内容

`qdisc`为`queueing discipline`，称为排队规则。内核如果需要通过某个网络接口发送数据包，都需要按照这里配置的规则进行发送。其选项最简单的为`pfifo`，表示不对数据包做任何处理，按照先入先出发送。`pfifo_fast`相对复杂，包括三个波段（band），每个波段优先级不同，先发送优先级高的数据包，而在每个波段中使用先进先出。数据包是按照服务类型（Type of Service, TOS）决定到哪一个波段，TOS是IP头部里面的一个字段，代表了当前包的优先级大小。

## DHCP与PXE

### 手动指定IP地址
在Linux中，当某台机器想要向其他机器发送包时，首先会进行判断，要去的这个地址和本机是同一个网段吗，只有是同一个网段的，它才会发送ARP请求，获取MAC地址。

否则，默认逻辑为：如果是一个跨网段调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。也就是本网段的其他主机无法收到该包，这也要求了手动指定的IP地址必须准确无误。

### DHCP
> 动态主机配置协议（Dynamic Host Configuration Protocol, DHCP）

相当于，预先配置好一段共享的IP地址，每一台新接入的机器都通过DHCP协议，来申请IP，用完后，还回去。

***工作方式***

1. DHCP Discover：新来机器使用IP为0.0.0.0发送一个广播包，目的IP为：255.255.255.255，以及使用本机的MAC地址作为源地址，而使用ff:ff:ff:ff:ff:ff作为目的MAC地址。广播包为一个**UDP**包，
2. DHCP Offer：DHCP Server收到该请求后，为其授权分配一个IP地址，并设定了授权的时间、网关、子网掩码等信息，同时保证不会将该IP分配给其他的主机。offer阶段，MAC目的地址与IP目的地址仍然都使用广播地址（因为请求分配IP的主机仍然不知道自己的IP地址）
3. DHCP Request：如果局域网内存在多个DHCP Server，那么这台机器会收到多个IP地址。通常它会选择最先到达的DHCP Offer。然后向网络中发送一个DHCP request**广播**数据包，告诉所有DHCP Server它接受了哪一台服务器提供的IP，并让其他服务器撤销之前的分配，用于分配给其他申请者。由于此时客户机还没有真正确定自己的IP，所以仍然使用0.0.0.0作为源IP，MAC/IP层使用广播地址作为目的地址。
4. 最后，DHCP Server会发送一个广播包ACK告知大家，新加入的成员。

上面可以看到，DHCP分配的IP是有租期的，客户机在租期过去50%的时候，直接向为其分配IP地址的服务器发送DHCP request包要求续期，当收到服务器的ACK响应后，会根据ACK中提供的信息，更新本机的信息。

### PXE

这里不记录了，只要了解下PXE的作用即可，具体再看文章。

> 预启动执行环境（Pre-boot Execution Environment, PXE）主要用于批量的安装操作系统。多用于数据中心中，在云计算中有较大用处

## 从物理层到MAC层

这里我们从网络协议的最底层开始讨论，如何将多台计算机连接起来进行通信。

对于两台计算机来说，最简单的方式通信方式是将这两台电脑直接用**网线连接**起来。

然而对于两台以上的计算机要进行通信的时候，则需要**集线器**将多台机器连接。集线器特点：
1. 工作在物理层
2. 将某个端口收到的字节，转发到**所有**其他端口

当然，如果仅是这样就会出现以下问题：
1. 这个包是发给谁的？总不能一直Hub内所有计算机都能接收到？
2. 如果多台计算机同时发送，会不会发生混乱？有没有谁先发、谁后发的规则？

以上问题就是MAC(媒体访问控制协议，Medium Access Control)层需要解决的问题了。**对于第一个问题**，也就出现了MAC地址，指定了该包是发送给谁的，计算机收到包后，会判断该包是否发送给自己的，如果不是，那么将直接丢弃。MAC层的网络包格式如下：
![](/img/post/computer_network/mac_format.jpg)

**对于第二个问题**，常用的解决策略是多路访问策略，主要有以下三种方式：
1. 信道划分，每个包只能从各自的信道发送与接收。该方法实现简单，但是利用率较差；
2. 轮流协议，即各包轮流发送；
3. 随机接入协议：即每个发送端不管当前局域网内是否拥堵，立即发送自己的包，一旦发现出错后，那么随机休眠一段时间后继续发送。常用的以太网就是使用这种策略进行发送。

回到集线器的问题上来说，由于其会转发包到其他所有端口上去，那么当机器数量较多时候，那么冲突发送的概率也就很大了。此外事实上，对于点对点发送的数据包，转发包到其他所有端口是无意义的，不会被接受，反而浪费带宽。解决这个问题的办法是**网桥，交换机**。由于这些设备在转发时，会对MAC头部检查以确定从哪个端口发送，所以这些设备工作在数据链路层。此外，这些设备都有**自学习算法**，可以自动构建转发表。

### ARP & RARP

**ARP**：当在一个局域网内，我们只知道对方IP，而不知道对方的MAC地址时，就可以通过ARP协议，发送一个**广播包**，获取指定IP机器的MAC地址。当然，机器会缓存ARP得到的结果，避免每次进行广播发送请求。

**RARP**：通过一个MAC地址获取对应的IP地址，这种协议在当前不太常用。之前有无盘工作站，即没有硬盘的机器，无法持久化ip地址到磁盘，但有网卡，这时候就可以使用RARP协议来获取IP地址。

## 交换机与VLAN

当一个局域网中，存在多台交换机时，并且构成环路时，可能出现**广播风暴**的问题，这是因为交换机在自学习的时候，会将包从剩余端口广播发送，当出现环路的时候，也就出现了没有尽头的局面，使得网络带宽被这些广播包占满，造成网络奔溃。

**STP**解决方案：核心思想就是打破图，生成树来解决这种环路。具体细节不再展开，明白其目的即可，为解决广播风暴而生。当然，STP也存在其缺点，因为每次网络拓扑变动，都会引起重新的建树，这一操作相对耗时，会造成一段时间内的网络不可用。

### VLAN

当机器数变多，交换机变多，随之而来的一个问题是，大量广播包在网络上发送，使得性能下降；以及由于广播的原因，可以通过抓包的方式获取即使不是发送给它的包内容，引起安全问题。

VLAN（虚拟局域网）的出现就是解决广播与安全这两个问题而生。使用VLAN，一个交换机上会连属于**多个局域网**的机器。具体做法为：在原来的MAC报文中新增一个TAG：VLAN ID。如果交换机是支持VLAN的，那么交换机在转发时，只会转发到具有相同VLAN ID的口。
![](/img/post/computer_network/vlan_mac_format.jpg)

## ICMP

Internet Control Message Protocol，互联网控制报文协议。工作在**IP层**，常用于错误诊断。
![](/img/post/computer_network/icmp_format.jpg)

主要分为两种:
1. 用于查询报文：如ping命令。在选项数据中，ping报文记录了发送时间，用于计算往返时间
2. 用于差错报文：例如告知终点不可达、源抑制、超时、重定向等。常用的命令有traceroute

### ping

这里需要提一点的是，在很多服务器上都是禁用ping的，因为过多的ping会造成带宽资源的浪费。此时我们可以使用telnet来代替ping。该协议基于TCP/IP。

### traceroute

用于差错报文，通常故意制造一些产生错误的场景来感知链路信息。例如
1. 故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器
2. 故意设置不分片，从而确定路径的MTU

## 网关

这里主要涉及网络层的概念，路由器为这里最重要的设备。

当两台主机互相通信时，首先判断两个IP是否为同一个网段，如果是，那么直接通过ARP协议获取目的主机的MAC地址，然后发送。如果不是同一个网段，那么该主机就会向网关发送该包，由网关进行转发。这里网关往往就是路由器，是一个三层设备，因为其需要解析到IP地址。

对于路由器来说，最重要的一个部分就是路由表了，主要分为静态路由与动态路由。其配置了一条条转发规则，确定发送给目的IP地址的包从哪个端口进行转发出去。

### 网关分类

根据转发过程中IP是否变化，来将网关分为转发网关与NAT网关。

#### 转发网关

在整个两台主机的通信过程中，源IP于目的IP一直不变，只是下层的数据链路层中的MAC地址一直在改变。

#### NAT网关

通常情况下，例如在家中，我们连接WIFI的设备的IP通常为：192.168.0.X等，而这些私有地址同时也可能是其他网络下的地址。仅仅通过这些IP是无法进行通信的，这时就需要NAT网关在转发到另一个网络时，需要将该IP地址映射为一个公有IP地址，在网络上传输的时候，将会用该公有IP地址。到底目的网络后，再根据映射关系进行映射找到目的主机。

这里涉及到的一个重要概念是IP转换，在一个网络中，可能会有多个私有地址转为同一个公有地址，那么当收到消息的时候，如果确定刚才是哪一台主机发送的包呢？答案是：NAT网关会以源IP+源端口的方式记录连接的NAT记录。内部采用哈希匹配算法来建立映射关系。

### 动态路由

我们可以通过指定命令去手动配置路由信息，来做到更细粒度的控制。具体看文章。

动态路由算法主要有两种: 距离矢量算法和链路状态算法。两种算法侧重点不同，各有优缺点，具体看文章。基于两种算法产生了两种协议：BGP协议和OSPF协议。

## UDP

### 特性
1. 无连接的
2. 不保证不丢失
3. 不保证按顺序到达
4. TCP是面向字节流的，而UD是基于**数据报**的，一个个地发，一个个地收
5. 没有拥塞控制
6. 无状态

UDP是面向无连接的。所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接特性。因此，建立连接客户端与服务端都需要有一定的资源开销。

### 使用场景
1. 需要资源少，在网络比较好的内网中，或者对于丢包不敏感的应用
2. 不需要一对一沟通，而是可以广播的应用
3. 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩。

关于丢包的场景，虽然UDP不保证，但我们可以通过自己在应用层控制重传

### 实际例子
1. 网页或者APP访问。在移动应用中，由于网络的不稳定，可能频繁出现TCP连接的重连等，使得浪费资源。QUIC协议的出现很大提升了性能。QUIC在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制。
2. 流媒体协议。
3. 实时游戏。
4. 物联网。

总之，在实时领域，UDP通常应用较为广泛。因为TCP的当中间某个包丢失后，会使得后面的所有包都无法被接受，而造成等待，这在实时领域是不给认可的。实时领域为了追求实时性，有时是可以忍受某个包丢失的。

## TCP

### 特点
1. 面向连接的
2. 有序的
3. 可靠的
4. 具有拥塞控制
5. 具有流量控制

还需要掌握的是三次握手，四次挥手的详细状态变化，以及为什么握手需要三次，挥手需要四次。

### 拥塞控制&流量控制

需要掌握的有：
1. 累计确认概念
2. 确认重发机制
3. 如何进行流量控制的，了解双方如何根据各自队列来协调发射与接收
4. 慢开始
5. 拥塞避免算法
6. 快重传

此外，最新的被采用的拥塞避免算法：TCP BBR算法。它主要针对以前算法存在的两个问题被提出:
1. 丢包并不代表网络拥塞，在现有的移动网络中，丢包现象广泛存在，如果一旦发现丢包就认为是网络拥塞了，会造成带宽浪费
2. 实际的包路由过程中，每个中间节点都会具有缓存，当该节点无法处理时，新来的包就会进入缓存，等待被处理。而事实上，缓存的存在会进一步影响延时，最理想的网络状态应该是，发送的速率与网络带宽达到一致。对于TCP拥塞控制来说，当真正发生拥塞时，各中间节点中的缓存都已经被填满了，然而这个时候已经晚了。使得延时更加大。而时延的增大进一步加大了包丢失的概率。

因此BBR主要的工作就是企图找到一个平衡点，就是通过不断的加快发送速度，将带宽填满，但是不填满中间设备的缓存，因为这样会增加延时，在这个平衡点可以很好的达到高带宽和低时延的平衡。

## HTTP

### HTTP2.0
1. HTTP1.1在应用层以**纯文本**的形式进行通信。每次通信都要完整的HTTP头。此外，不考虑HTTP1.1下的pipeline模式，每次请求都是一来一回依次发送，存在实时性与并发性问题。
2. HTTP2.0对头部进行压缩，在链接两端建立一个索引表，对相同的头只发送索引表中的索引，从而节约了空间
3. HTTP2.0将一个TCP连接切分成多个流，每个流都有自己的ID，而且可以双向发送，此外，每个流具有优先级，可以先处理优先级高的流。这就使得多个请求可以并发发送。
4. HTTP2.0将所有的传输信息分割为更小的信息和帧，并对它们采用二进制编码。常见的帧有Header帧，用于传输Header内容，并会开启一个新的流。再就是Data帧，用来传输正文实体。多个Data帧属于同一个流。

![](/img/post/computer_network/http2.jpg)

### QUIC

HTTP2.0虽然增加了并发性，但由于其基于TCO协议，处理包是有严格顺序限制，所以会出现如下情况：

当其中一个数据包遇到问题，TCP连接需要等待这个包完成重传才能继续进行。虽然HTTP2.0通过多个流，使得逻辑上一个TCP连接上并行传输，然而其实还是有顺序的，上图中，stream2的帧还没有收到，stream1中的帧也会因此阻塞。

QUIC特性：
1. 基于UDP，自己维护连接，以一个64位随机数作为ID来标识。
2. 自定义重传机制。类似TCP的序号与应答机制。QUIC每次使用递增的序号进行发送，即使重发也使用递增的序号。并且使用offset来标识两个数据包是否相同
3. 无阻塞的多路复用。同HTTP2.0一样，同一条QUIC连接上可以创建多个stream，来发送多个HTTP请求。但是由于QUIC基于UDP，一个连接上的多个流之间没有依赖，即使stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2那个包需要重传，但是stream3无需等待，可以直接进行处理
4. 自定义流量控制。在TCP中，接收端窗口的起始点是下一个要接受并且ACK的包，即便后来的包都到了，放在缓存里，窗口也不能右移，因为TCP的ACK机制是基于序列号的累计应答，一旦ACK了一个序号，说明前面都收到了，所以只要前面没到，后面到了也不能ACK。而QUIC基于offset，每个包到来进入缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发即可。窗口的起始位置为当前收到的最大offset。
