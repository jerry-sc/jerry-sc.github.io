---
layout: post
title: Linux性能优化
date: 2019-01-21
author: Jerry
header-style: text
catalog: true
tags:
 - Linux
---

## 平均负载

我们可以通过`uptime`命令获取系统的平均负载
```shell
> uptime
14:58:54 up 432 days,  1:11,  1 user,  load average: 0.00, 0.00, 0.00
```
这里需要关注的是最后三列，分别表示过去1分钟、5分钟、15分钟的平均负载。

**注意：平均负载不等于CPU使用率**

> 平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均**进程数**。

- 可运行状态进程包括**正在使用CPU**的进程以及正在**等待CPU**的就绪进程，对应进程状态R
- 不可中断进程是指正处于内核态关键流程中的进程，并不能被中断。对应进程状态D（Disk Sleep）。例如等待硬件设备IO响应。如果此时进程被打断那么会引起进程数据与磁盘数据不一致，因此这里不可中断是对系统进程与硬件设备的保护。

OS中分为两种中断，可中断与不可中断，分别对应的进程状态为S与D。
- 处于可中断的进程通常因为**等待某某事件发生（如等待socket连接，等待信号量）**而被挂起。而当这些等待事件发生时，这些进程就会被唤醒。
- 处于不可中断的原因一般如上面所述，进程处于内核态关键流程中，一旦被中断，会引发错误。通常而言，处于该状态的时间较为短暂。

[Linux进程状态解析之R、S、D、T、Z、X](https://www.cnblogs.com/YDDMAX/p/4979878.html)

通过`uptime`命令查看系统平均负载时，我们更应该关注的是**整体趋势变化**，而不是某一个值的大小。作者建议**当平均负载高于CPU数量70%的时候**，就应该排除为什么负载高的问题了。

### 平均负载与CPU使用率

再次强调下，两者属于不同范畴，要从各自定义出发去理解。平均负载有时与CPU使用率并不一致。
- CPU密集型进程，使用大量CPU会导致平均负载升高，此时这两者一致
- IO密集型进程，等待IO也会导致平均负载升高，但此时CPU使用率不一定高

也就是说，平均负载高有可能是CPU密集引起，或者由于IO密集引起。

### 性能检测工具

可以使用`sysstat`包下的`mpstat`与`pidstat`
- `mpstat`是一个常用的多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标
- `pidstat`是一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、IO以及上下文切换等性能指标

