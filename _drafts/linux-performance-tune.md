---
layout: post
title: Linux性能优化
date: 2019-01-21
author: Jerry
header-style: text
catalog: true
tags:
 - Linux
---

## 平均负载

我们可以通过`uptime`命令获取系统的平均负载
```shell
> uptime
14:58:54 up 432 days,  1:11,  1 user,  load average: 0.00, 0.00, 0.00
```
这里需要关注的是最后三列，分别表示过去1分钟、5分钟、15分钟的平均负载。

**注意：平均负载不等于CPU使用率**

> 平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均**进程数**。

- 可运行状态进程包括**正在使用CPU**的进程以及正在**等待CPU**的就绪进程，对应进程状态R
- 不可中断进程是指正处于内核态关键流程中的进程，并不能被中断。对应进程状态D（Disk Sleep）。

### 不可中断与可中断

OS中分为两种中断，可中断与不可中断，分别对应的进程状态为S与D。
- 处于可中断的进程通常因为**等待某某事件发生（如等待socket连接，等待信号量）**而被挂起。而当这些等待事件发生时，这些进程就会被唤醒。
- 处于不可中断的原因一般如上面所述，进程处于内核态关键流程中，一旦被中断，会引发错误。通常而言，处于该状态的时间较为短暂。比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动代码，并与对应的物理设备进行交互。这时就需要对进程进行保护，以免被中断后，**造成设备陷入不可控状态**。可见不可中断是对系统进程与硬件设备的保护。

按照我的理解，仍旧以read系统调用举例。当CPU执行与设备驱动的内核代码时，即当执行设备控制的时候，这时进程处于D状态。而当控制代码处理完毕后，IO设备开始工作后，即不需要CPU再进行干预时，这时进程处于S，休眠状态，等待DMA数据传送完毕。当数据传输完毕，发送中断后，然后进程再次回到R状态

### 进程状态
[Linux进程状态解析之R、S、D、T、Z、X](https://www.cnblogs.com/YDDMAX/p/4979878.html)
- R
- S
- D
- Z是zombie的缩写，表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（如进程的描述符、PID等）
- I是Idle缩写，表示空闲状态，用在不可中断睡眠的内核线程上，该类进程没有任何负载。
- T或t，表示进程处于暂停或者跟踪状态，当我们用gdb调试一个进程时，进程就会处于该状态
- X表示进程已消亡，也就不会再top或者ps命令中看到

通过`uptime`命令查看系统平均负载时，我们更应该关注的是**整体趋势变化**，而不是某一个值的大小。作者建议**当平均负载高于CPU数量70%的时候**，就应该排除为什么负载高的问题了。

### 平均负载与CPU使用率

再次强调下，两者属于不同范畴，要从各自定义出发去理解。平均负载有时与CPU使用率并不一致。
- CPU密集型进程，使用大量CPU会导致平均负载升高，此时这两者一致
- IO密集型进程，等待IO也会导致平均负载升高，但此时CPU使用率不一定高

也就是说，平均负载高有可能是CPU密集引起，或者由于IO密集引起。

### 性能检测工具

#### sysstat
可以使用`sysstat`包下的`mpstat`与`pidstat`
- `mpstat`是一个常用的多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标
- `pidstat`是一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、IO以及上下文切换等性能指标

#### dstat

该工具可以同时查看CPU和IO这两种资源的使用情况，便于对比分析

#### strace

常用于跟踪进程的**系统调用**情况

#### perf

用于查看占用CPU的内核函数

#### pstree

查看进程的父子关系

## CPU上下文切换

上下文切换时由于要保持现场，是需要开销的，所以频繁的上下文切换会导致性能低下。

CPU上下文可以分为三类：

### 进程上下文切换

进程的上下文切换相比其他两类切换更加重，更加占用性能。这是因为进程上下文切换不仅包括虚拟内存、栈、全局变量等用户空间的资源，也包括内核堆栈、寄存器等内核空间的状态。

造成进程切换的原因有：
- 时间片用完
- 进程运行资源不足
- 主动sleep挂起
- 高优先级抢占
- 硬件中断执行中断程序

### 线程上下文切换

由于现代OS线程才是调度的基本单位，而进程是资源拥有的基本单位。线程的切换更加轻量与高效。这是因为在同一进程内的线程切换时，只需保存各线程自己的栈和寄存器，而不需保存虚拟内存那些，因为那些是共享的。

当然不同进程内的线程切换时，由于资源不共享，所以先要进行进程切换。

### 中断上下文切换

为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。

但中断上下文切换并不涉及到进程的用户态，所以即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。于是，相比进程上下文切换来说，也更加轻量。

### 如何查看CPU上下文切换情况

同样可以通过`vmstat`来查看系统情况。
- `cs`列context switch，表示每秒上下文切换次数
- `in`列interrupt，表示每秒中断次数
- 其他字段可以man查询

同样可以通过`pidstat`命令加上`-w`参数来查看进程的上下文切换情况。需要注意的是两列：
- `cswch`表示每秒自愿上下文切换次数，如进程无法获取自愿导致的切换
- `nvcswch`表示每秒非自愿上下文切换次数，如时间片用完等强制发生的切换

注意：`-w`参数下只会显示进程的数据，而不会统计线程切换的数据，可以通过`-wt`来包含进线程数据

此外，我们可以通过读取`/proc/interrupts`文件来查看由于**是哪种中断类型**引起上下文切换次数

### 上下文切换多少次合理

根据作者建议，这个数值取决于CPU性能，如果系统上下文切换次数比较稳定，并且一万以内那么都算正常。如果出现数量级增长，就很可能发生问题。我们可以根据上下文切换的类型，来进一步猜测问题所在，如
- 自愿上下文变多了，说明进程都在等待资源，有可能发生了IO等问题
- 非自愿上下文切换变多了，说明进程都在被强制调度，都在抢CPU，说明CPU成了瓶颈
- 中断次数变多了，说明CPU被中断处理程序占用，需要通过查看`/proc/interrupts`来分析具体的中断类型

## CPU使用率

可以通过以下命令获取系统每个CPU不同场景下的使用率情况，以及整体的使用率情况。这里的数字单位是节拍数。为了维护CPU时间，Linux通过事先定义的节拍率来出发时钟中断，使用全局变量`Jiffies`记录**开机以来**的节拍数。每发生一次时钟中断，就+1.
```shell
> cat /proc/stat | grep ^cpu
cpu  6330964998 0 13176596 8568527998 5856564 0 765996 0 0 0
cpu0 1370073649 0 3186942 2354338860 1493387 0 165629 0 0 0
cpu1 2135161003 0 2985880 1590712563 1560081 0 165150 0 0 0
cpu2 1354084485 0 3602822 2370125834 1556406 0 180915 0 0 0
cpu3 1471645860 0 3400951 2253350740 1246689 0 254302 0 0 0
```

这里记录的不同场景有：
- `user`(us)：代表用户态CPU时间。不包括下面nice时间，但包括guest时间
- `nice`(ni)：代表**低优先级用户态**CPU时间，也就是进程的nice值被调整为1-19之间时的CPU时间。而nice取值为-20到19，数值越大，优先级越低
- `system`(sys)：代表内核态CPU时间
- `idle`(id)：代表空闲时间，但不包括IO等待时间
- `iowait`(wa)：代表等待IO的CPU时间。需要注意下该值的计算方法，iowait+idle才真正表示CPU空闲的时间，即iowait统计的是**当CPU空闲以及至少一个IO进程在运行**的时间，iowait为0并不能代表当前没有IO进程，可能只不过当时还有其他进程在占用cpu。此外反之，当iowait很大时，我们也无法光凭这个值就断定系统有很多进程在等待IO，可能只有一个。
- `irq`(hi)：代表处理硬中断的CPU时间
- `softirq`(si)：代表处理软中断CPU时间
- `steal`(st)：虚拟化中的值，当系统运行在虚拟机中，而物理机上还存在其他虚拟机，该值表示被其他虚拟机抢占的CPU时间。通常该值较大表示物理机CPU不足
- `guest`(guest)：代表通过虚拟化运行其他OS的时间，也就是虚拟机的CPU时间

> CPU使用率，就是除了空闲时间外的其他时间占总CPU时间的百分比

由于操作系统会不断更新/proc/stat中数据，所以只需要根据该文件就可以计算出一段时间内的cpu使用率情况。诸如`top`等命令就是这样CPU使用率的，该命令默认统计3秒内的使用率

当我们使用`top`命令查看使用率时，我们可以看到所有CPU的各个场景平均使用情况，以及各个进程的CPU总的使用情况，但无法看到各个进程在各个场景下的CPU使用情况。这是我们仍然可以通过`pidstat`命令来查看更加详细的使用情况，以此来定位进程级的CPU使用情况。

当定位到进程级之后，我们可以继续使用`perf`命令来查看哪个函数或者指令占用CPU时钟最多。

### 系统CPU使用率很高，但为什么找不到CPU的应用?

碰到常规问题无法解释CPU使用率情况时，即当我么通过`top`、`ps aux`等命令无法找到CPU使用率高的应用，但系统CPU使用率却很高的情况时，首先要想到有可能是**短时应用**导致的问题，比如以下两种情况：
- 应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过top等工具也不容易发现
- 应用本身在不停地奔溃重启，而启动过程的资源初始化，很可能占用相当多的CPU

对于这类进程，我们可以用`pstree`或者`execsnoop`命令找到它们的父进程，再从父进程所在的应用入手，排查问题的根源

## 系统出现大量不可中断进程和僵尸进程

### 僵尸进程出现的原因

正常情况下，当一个进程创建了子进程之后，它应该通过系统调用`wait`或者`waitpid`等待子进程结束，然后回收子进程资源（分配给子进程的进程描述符等)；此外，当子进程在结束时，会向它的父进程发送`SIGCHILD`信号，所以父进程也可以注册该信号的处理函数，异步回收资源。

然而如果父进程没有按照上述两个方法做，或者子进程执行太快，父进程还没有来得及处理子进程的状态，子进程就已经退出。这时，子进程就变成了僵尸进程。

通常，僵尸进程持续的时间较短，在父进程回收它的资源后就会消亡；或者在父进程退出后，由init进程回收后也会消亡。

然而，如果父进程长时间存在，却不回收子进程资源，那么僵尸进程会一直存在。由于这些僵尸进程占用着进程描述符，长时间不清理，会使得无法创建新的进程。

### 僵尸进程的诊断

僵尸进程的排查相对容易，可以使用`pstree`找出父进程，然后查看父进程代码，检查`wait`或者`pidwait`的调用，或是`SIGCHLD`信号处理函数的注册即可

### 不可中断进程诊断

不可中断进程通常持续的时间很短，若长时间存在，那么出现问题的可能性较大。我们可以通过状态D的进程，使用`strace`找出系统调用函数，进一步分析。有时，当状态为D的进程为僵尸进程时，那么该命令就不工作了，此时，我们可以通过`perf`来找出调用函数。