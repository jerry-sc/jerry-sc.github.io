---
layout: post
title: Linux性能优化
date: 2019-01-21
author: Jerry
header-style: text
catalog: true
tags:
 - Linux
---

## 平均负载

我们可以通过`uptime`命令获取系统的平均负载
```shell
> uptime
14:58:54 up 432 days,  1:11,  1 user,  load average: 0.00, 0.00, 0.00
```
这里需要关注的是最后三列，分别表示过去1分钟、5分钟、15分钟的平均负载。

**注意：平均负载不等于CPU使用率**

> 平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均**进程数**。

- 可运行状态进程包括**正在使用CPU**的进程以及正在**等待CPU**的就绪进程，对应进程状态R
- 不可中断进程是指正处于内核态关键流程中的进程，并不能被中断。对应进程状态D（Disk Sleep）。例如等待硬件设备IO响应。如果此时进程被打断那么会引起进程数据与磁盘数据不一致，因此这里不可中断是对系统进程与硬件设备的保护。

OS中分为两种中断，可中断与不可中断，分别对应的进程状态为S与D。
- 处于可中断的进程通常因为**等待某某事件发生（如等待socket连接，等待信号量）**而被挂起。而当这些等待事件发生时，这些进程就会被唤醒。
- 处于不可中断的原因一般如上面所述，进程处于内核态关键流程中，一旦被中断，会引发错误。通常而言，处于该状态的时间较为短暂。

[Linux进程状态解析之R、S、D、T、Z、X](https://www.cnblogs.com/YDDMAX/p/4979878.html)

通过`uptime`命令查看系统平均负载时，我们更应该关注的是**整体趋势变化**，而不是某一个值的大小。作者建议**当平均负载高于CPU数量70%的时候**，就应该排除为什么负载高的问题了。

### 平均负载与CPU使用率

再次强调下，两者属于不同范畴，要从各自定义出发去理解。平均负载有时与CPU使用率并不一致。
- CPU密集型进程，使用大量CPU会导致平均负载升高，此时这两者一致
- IO密集型进程，等待IO也会导致平均负载升高，但此时CPU使用率不一定高

也就是说，平均负载高有可能是CPU密集引起，或者由于IO密集引起。

### 性能检测工具

可以使用`sysstat`包下的`mpstat`与`pidstat`
- `mpstat`是一个常用的多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标
- `pidstat`是一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、IO以及上下文切换等性能指标

## CPU上下文切换

上下文切换时由于要保持现场，是需要开销的，所以频繁的上下文切换会导致性能低下。

CPU上下文可以分为三类：

### 进程上下文切换

进程的上下文切换相比其他两类切换更加重，更加占用性能。这是因为进程上下文切换不仅包括虚拟内存、栈、全局变量等用户空间的资源，也包括内核堆栈、寄存器等内核空间的状态。

造成进程切换的原因有：
- 时间片用完
- 进程运行资源不足
- 主动sleep挂起
- 高优先级抢占
- 硬件中断执行中断程序

### 线程上下文切换

由于现代OS线程才是调度的基本单位，而进程是资源拥有的基本单位。线程的切换更加轻量与高效。这是因为在同一进程内的线程切换时，只需保存各线程自己的栈和寄存器，而不需保存虚拟内存那些，因为那些是共享的。

当然不同进程内的线程切换时，由于资源不共享，所以先要进行进程切换。

### 中断上下文切换

为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。

但中断上下文切换并不涉及到进程的用户态，所以即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。于是，相比进程上下文切换来说，也更加轻量。

### 如何查看CPU上下文切换情况

同样可以通过`vmstat`来查看系统情况。
- `cs`列context switch，表示每秒上下文切换次数
- `in`列interrupt，表示每秒中断次数
- 其他字段可以man查询

同样可以通过`pidstat`命令加上`-w`参数来查看进程的上下文切换情况。需要注意的是两列：
- `cswch`表示每秒自愿上下文切换次数，如进程无法获取自愿导致的切换
- `nvcswch`表示每秒非自愿上下文切换次数，如时间片用完等强制发生的切换

注意：`-w`参数下只会显示进程的数据，而不会统计线程切换的数据，可以通过`-wt`来包含进线程数据

此外，我们可以通过读取`/proc/interrupts`文件来查看由于**是哪种中断类型**引起上下文切换次数

### 上下文切换多少次合理

根据作者建议，这个数值取决于CPU性能，如果系统上下文切换次数比较稳定，并且一万以内那么都算正常。如果出现数量级增长，就很可能发生问题。我们可以根据上下文切换的类型，来进一步猜测问题所在，如
- 自愿上下文变多了，说明进程都在等待资源，有可能发生了IO等问题
- 非自愿上下文切换变多了，说明进程都在被强制调度，都在抢CPU，说明CPU成了瓶颈
- 中断次数变多了，说明CPU被中断处理程序占用，需要通过查看`/proc/interrupts`来分析具体的中断类型

## CPU使用率

可以通过以下命令获取系统每个CPU不同场景下的使用率情况，以及整体的使用率情况。这里的数字单位是节拍数。为了维护CPU时间，Linux通过事先定义的节拍率来出发时钟中断，使用全局变量`Jiffies`记录**开机以来**的节拍数。每发生一次时钟中断，就+1.
```shell
> cat /proc/stat | grep ^cpu
cpu  6330964998 0 13176596 8568527998 5856564 0 765996 0 0 0
cpu0 1370073649 0 3186942 2354338860 1493387 0 165629 0 0 0
cpu1 2135161003 0 2985880 1590712563 1560081 0 165150 0 0 0
cpu2 1354084485 0 3602822 2370125834 1556406 0 180915 0 0 0
cpu3 1471645860 0 3400951 2253350740 1246689 0 254302 0 0 0
```

这里记录的不同场景有：
- `user`(us)：代表用户态CPU时间。不包括下面nice时间，但包括guest时间
- `nice`(ni)：代表**低优先级用户态**CPU时间，也就是进程的nice值被调整为1-19之间时的CPU时间。而nice取值为-20到19，数值越大，优先级越低
- `system`(sys)：代表内核态CPU时间
- `idle`(id)：代表空闲时间，但不包括IO等待时间
- `iowait`(wa)：代表等待IO的CPU时间
- `irq`(hi)：代表处理硬中断的CPU时间
- `softirq`(si)：代表处理软中断CPU时间
- `steal`(st)：虚拟化中的值，当系统运行在虚拟机中，而物理机上还存在其他虚拟机，该值表示被其他虚拟机抢占的CPU时间。通常该值较大表示物理机CPU不足
- `guest`(guest)：代表通过虚拟化运行其他OS的时间，也就是虚拟机的CPU时间

> CPU使用率，就是除了空闲时间外的其他时间占总CPU时间的百分比

由于操作系统会不断更新/proc/stat中数据，所以只需要根据该文件就可以计算出一段时间内的cpu使用率情况。诸如`top`等命令就是这样CPU使用率的，该命令默认统计3秒内的使用率

当我们使用`top`命令查看使用率时，我们可以看到所有CPU的各个场景平均使用情况，以及各个进程的CPU总的使用情况，但无法看到各个进程在各个场景下的CPU使用情况。这是我们仍然可以通过`pidstat`命令来查看更加详细的使用情况，以此来定位进程级的CPU使用情况。

当定位到进程级之后，我们可以继续使用`perf`命令来查看哪个函数或者指令占用CPU时钟最多。

### 系统CPU使用率很高，但为什么找不到CPU的应用?

碰到常规问题无法解释CPU使用率情况时，即当我么通过`top`、`ps aux`等命令无法找到CPU使用率高的应用，但系统CPU使用率却很高的情况时，首先要想到有可能是**短时应用**导致的问题，比如以下两种情况：
- 应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过top等工具也不容易发现
- 应用本身在不停地奔溃重启，而启动过程的资源初始化，很可能占用相当多的CPU

对于这类进程，我们可以用`pstree`或者`execsnoop`命令找到它们的父进程，再从父进程所在的应用入手，排查问题的根源